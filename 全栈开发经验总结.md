# Day1 登录实现

## Pinia的使用

新版Vue3最好还是使用pinia来进行数据管理而不是vuex

Pinia 是 Vue.js 的官方状态管理库，用于集中管理和共享应用程序的状态。它是 Vuex 的替代方案，专为 Vue 3 设计，提供了更直观、简洁的 API 和更好的 TypeScript 支持。

### 核心概念

#### 1. **Store**

Store 是 Pinia 的核心概念，用于保存状态和业务逻辑。它包含三个主要部分：

- **State（状态）**：响应式对象，存储应用的状态数据，类似于 Vue 组件中的 `data`。
- **Getters（计算属性）**：用于派生状态，类似于 Vue 组件中的 `computed`，是缓存的，只有在依赖的状态发生变化时才会重新计算。
- **Actions（动作）**：用于修改状态或执行复杂业务逻辑，可以包含异步操作。

例如我在对于登录时创建的pinia

注意authStore.ts文件要先引入需要的文件：

```ts
import { defineStore } from 'pinia';
import axios from 'axios';
import { User, Credentials } from '../types/types';
```

这里的 { User, Credentials }是ts中为了定义类型的接口，在后面函数中对于函数形参类型的定义需要用到：

```ts
// src/types.ts
export interface User {
    username: string;
    // 其他用户信息可以根据需要添加
  }
  
  export interface Credentials {
    username: string;
    password: string;
  }
```

回到authStore.ts文件，我这里创建了状态，这里的isAuthenticated是用于判断用户在当前页面是否处于登录状态的关键状态数据，这里的user则作为登录成功后显示用户名的数据：

```ts
state: () => ({
    isAuthenticated: false,
    user: null as User | null
  }),
```

然后就是对应的action方法，用于用户登录，注册，登出时调用的函数：

```ts
 actions: {
    async login(credentials: Credentials) {
      try {
        // 发送登录请求到后端
        const response = await axios.post('https://jy8b5cnnmg.hzh.sealos.run/login', credentials);
        console.log(response)
        // 返回的用户名是存在data.user.username中的
        // 如果登录成功，更新状态
        this.isAuthenticated = true;
        this.user = response.data.user.username;

        // 可选：保存用户信息到 localStorage 或其他存储
        localStorage.setItem('user', JSON.stringify(response.data));
      } catch (error) {
        // 如果登录失败，抛出错误
        throw new Error('Login failed. Please check your credentials.');
      }
    },

    //添加一个 register action，用于处理注册逻辑。
    async register(credentials: Credentials) {
      try {
        const response = await axios.post('https://jy8b5cnnmg.hzh.sealos.run/adduser', credentials);
        // console.log(response)
        if (response.data.code == 401 || response.data.code == 400) {
          throw new Error('注册失败,用户名已存在');
        } else {
          this.isAuthenticated = true;
          this.user = response.data;
          localStorage.setItem('user', JSON.stringify(response.data));
        }

      } catch (error) {
        throw new Error('注册失败,用户名已存在');
      }
    },

    // 处理退出登录逻辑
    logout() {
      // 登出逻辑
      this.isAuthenticated = false;
      this.user = null;
      // 可选：清除用户信息
      localStorage.removeItem('user');
    }
  }
```



下面是完整代码：

```ts
// src/stores/authStore.ts


export const useAuthStore = defineStore('auth', {
  state: () => ({
    isAuthenticated: false,
    user: null as User | null
  }),
  actions: {
    async login(credentials: Credentials) {
      try {
        // 发送登录请求到后端
        const response = await axios.post('https://jy8b5cnnmg.hzh.sealos.run/login', credentials);
        console.log(response)
        // 返回的用户名是存在data.user.username中的
        // 如果登录成功，更新状态
        this.isAuthenticated = true;
        this.user = response.data.user.username;

        // 可选：保存用户信息到 localStorage 或其他存储
        localStorage.setItem('user', JSON.stringify(response.data));
      } catch (error) {
        // 如果登录失败，抛出错误
        throw new Error('Login failed. Please check your credentials.');
      }
    },

    //添加一个 register action，用于处理注册逻辑。
    async register(credentials: Credentials) {
      try {
        const response = await axios.post('https://jy8b5cnnmg.hzh.sealos.run/adduser', credentials);
        // console.log(response)
        if (response.data.code == 401 || response.data.code == 400) {
          throw new Error('注册失败,用户名已存在');
        } else {
          this.isAuthenticated = true;
          this.user = response.data;
          localStorage.setItem('user', JSON.stringify(response.data));
        }

      } catch (error) {
        throw new Error('注册失败,用户名已存在');
      }
    },

    // 处理退出登录逻辑
    logout() {
      // 登出逻辑
      this.isAuthenticated = false; //这里将登录的状态标识改为false了
      this.user = null;
      // 可选：清除用户信息
      localStorage.removeItem('user');
    }
  }
});
```



#### 2. **defineStore**

`defineStore` 是定义 Store 的函数，需要传入一个唯一的名称作为 ID。Store 可以通过 `setup` 函数或 `option` 对象来定义。



```ts
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
  }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++;
    },
  },
});
```

#### 3. **使用 Store**

在对应的登录文件中使用store，注意要先引入：

await store.login({ username: username.value, password: password.value });执行的操作是找到store中对应名字为login的action函数并传入参数{ username: username.value, password: password.value }来执行它，执行成功没出问题就跳转到主页面。

```vue
<script setup>
  import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '../stores/authStore';

const store = useAuthStore();
const router = useRouter();
const username = ref('');
const password = ref('');

const handleLogin = async () => {
  try {
    await store.login({ username: username.value, password: password.value });
    router.push('/home'); // 登录成功后跳转到主页
  } catch (error) {
    alert('登录失败，请检查你的账号密码');
  }
};
  </script>
```

**状态标识也有大作用，可以根据当前store中状态标识的值来显示不同的内容。**

```ts
const store = useAuthStore();

// 三元表达式，用于判断登录状态的store.$state.isAuthenticated值为true的话就显示'退出登录' 
// 使用 computed 属性来动态计算 title使得它是响应式的
const title = computed(() => {
  return store.$state.isAuthenticated ? '退出登录' : '登录';
});	
```

### 特点

1. **类型安全**：Pinia 提供了对 TypeScript 的良好支持，包括类型推断和自动补全。
2. **DevTools 集成**：支持 Vue DevTools，方便调试。
3. **模块化和灵活性**：支持将状态分割为不同的模块，便于大型应用的状态管理。
4. **轻量级**：代码库比 Vuex 更小。
5. **插件支持**：可以通过插件扩展功能，例如状态持久化。

### 使用场景

Pinia 适用于跨组件或页面共享状态的场景，例如全局主题、购物车数据等。不过，它也有适用边界，不能滥用，否则可能增加性能消耗或内存泄漏。

### 示例：状态持久化

通过插件，Pinia 可以实现状态持久化，例如使用 `pinia-plugin-persistedstate`。

JavaScript复制

```javascript
import { createPinia } from 'pinia';
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';

const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);
```

### 总结

Pinia 提供了一个现代化、高效且灵活的状态管理解决方案，特别适合 Vue 3 项目。它简化了状态管理的复杂性，同时提供了强大的功能和良好的开发体验。

## 路由守卫

在完成登录的功能时，最重要的就是路由守卫了

在现代前端开发中，登录操作是常见的功能之一，而路由守卫（Route Guard）是实现登录状态管理的重要工具。它主要用于控制用户在不同路由之间的访问权限，确保用户在未登录时无法访问某些受保护的页面，或者在登录后被重定向到合适的页面。以下是关于路由守卫的实现和作用的详细讲解。

简单点说,就是利用前面的pinia定义的状态变量来使用全局路由守卫（如 `beforeEach`）来实现登录状态的检查。当登录状态为flase的时候就不给访问页面的权限.仍然跳到登陆界面.

成功了就继续next();

```ts
router.beforeEach((to, _from, next) => {
  const authStore = useAuthStore();
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  if (requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'Login' });
  } else {
    next();
  }
});
```



------

### 1. **路由守卫的作用**

路由守卫的作用是拦截用户的路由跳转请求，根据用户的登录状态或其他条件，决定是否允许用户访问目标路由。主要作用包括：

- **权限控制**：确保用户只能访问他们有权限的页面。例如，未登录用户不能访问用户中心或管理页面。
- **用户体验优化**：避免用户在未登录状态下访问受保护的页面后被强制跳转到登录页，然后再跳转回原页面。
- **安全性**：防止用户通过直接输入 URL 绕过登录验证，访问敏感信息。
- **状态管理**：根据用户的登录状态动态调整路由行为。

------

### 2. **实现路由守卫的步骤**

以 Vue.js 为例，结合 Vue Router 和 Pinia（或其他状态管理库），实现登录操作中的路由守卫,当登录状态为flase的时候就不给访问页面的权限

#### **2.1 定义登录状态**

假设我们使用 Pinia 来管理用户的登录状态，定义一个 `authStore`：

JavaScript复制

```javascript
// stores/auth.js
import { defineStore } from 'pinia';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    isAuthenticated: false,
    user: null,
  }),
  actions: {
    login(user) {
      this.isAuthenticated = true;
      this.user = user;
    },
    logout() {
      this.isAuthenticated = false;
      this.user = null;
    },
  },
});
```

#### **2.2 设置路由守卫**

在 Vue Router 中，可以使用全局路由守卫（如 `beforeEach`）来实现登录状态的检查。

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router';
import { useAuthStore } from '@/stores/auth';

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/Home.vue'),
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true }, // 标记需要登录才能访问的路由
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

router.beforeEach((to, from, next) => {
  const authStore = useAuthStore();
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);

  if (requiresAuth && !authStore.isAuthenticated) {
    // 如果目标路由需要登录，但用户未登录，重定向到登录页
    next({ name: 'Login' });
  } else if (to.name === 'Login' && authStore.isAuthenticated) {
    // 如果用户已登录，但尝试访问登录页，重定向到主页
    next({ name: 'Home' });
  } else {
    // 其他情况允许访问
    next();
  }
});

export default router;
```

#### **2.3 在登录组件中处理登录逻辑**

在登录组件中，调用 Pinia 的 `login` 方法，并通过路由跳转到目标页面。

vue复制

```vue
<template>
  <div>
    <h1>Login</h1>
    <button @click="handleLogin">Login</button>
  </div>
</template>

<script setup>
import { useAuthStore } from '@/stores/auth';
import { useRoute, useRouter } from 'vue-router';

const authStore = useAuthStore();
const router = useRouter();
const route = useRoute();

const handleLogin = () => {
  // 模拟登录逻辑
  authStore.login({ name: 'John Doe' });
  const redirectPath = route.query.redirect || '/';
  router.push(redirectPath);
};
</script>
```

------

### 3. **路由守卫的实现原理**

路由守卫的核心是 Vue Router 提供的全局前置守卫 `beforeEach`。它会在路由跳转之前被触发，允许开发者执行自定义逻辑：

- **`to`**：目标路由的信息。
- **`from`**：当前路由的信息。
- **`next`**：一个回调函数，用于决定是否允许跳转。`next()` 允许跳转，`next(false)` 阻止跳转，`next({ path: '/' })` 重定向到其他路由。

通过检查目标路由的元信息（如 `meta.requiresAuth`）和用户的登录状态，路由守卫可以灵活地控制用户的访问权限。

------

### 4. **其他路由守卫类型**

除了全局前置守卫 `beforeEach`，Vue Router 还提供了其他类型的路由守卫：

- **全局后置守卫**：`afterEach`，在路由跳转完成后执行，常用于日志记录或页面标题设置。
- **路由独享守卫**：`beforeEnter`，定义在路由对象中，仅对该路由生效。
- **组件内守卫**：`beforeRouteEnter`、`beforeRouteUpdate` 和 `beforeRouteLeave`，用于在组件内部控制路由行为。

------

### 5. **总结**

路由守卫是实现登录状态管理和权限控制的关键工具。通过结合 Vue Router 和 Pinia，可以灵活地控制用户的路由跳转行为，确保应用的安全性和用户体验。路由守卫不仅可以用于登录状态管理，还可以扩展到其他复杂的权限控制场景，例如角色权限管理或动态路由加载。

## 后端

### 基于云开发

利用sealos部署数据库和云函数，真好用。。。

[Sealos Cloud](https://hzh.sealos.run/?bd_vid=&k=&s=)

### 云函数

#### 网站数据的云函数

就是基本的增删改查，基于mongodb的

当然不可避免的一步就是，导入数据库，指定集合名

```ts
// 获取 MongoDB 实例
    const db = cloud.mongo.db;

    // 指定集合名称（根据您的数据库集合名称修改）
    const collectionName = 'weblist'; // 替换为您的集合名称
    const collection = db.collection(collectionName);
```

然后进行基本的查询。注意find方法内是{"键名"：键值}，返回的是对应的json对象，只有{}默认是查询所有对象

.toArray();转化为数组方便数据返回为[{对象1},{对象2}]的形式

查询一个就是await collection.findOne（）

插入一个就是await collection.insertOne（）

删除一个就是await collection.deleteOne（）

多个就去掉One就行

```ts
import cloud from '@lafjs/cloud';

export default async function (ctx: FunctionContext) {
  try {
    // 获取 MongoDB 实例
    const db = cloud.mongo.db;

    // 指定集合名称（根据您的数据库集合名称修改）
    const collectionName = 'weblist'; // 替换为您的集合名称
    const collection = db.collection(collectionName);

    // 查询所有数据
    const result = await collection.find({}).toArray();

    // 返回查询结果
    return {
      code: 200,
      data: result,
      message: 'Data retrieved successfully'
    };
  } catch (error) {
    console.error('Error retrieving data:', error);
    return {
      code: 500,
      message: 'Error retrieving data'
    };
  }
}
```

#### 基本逻辑

登录逻辑就是，前端对对应的接口进行post请求，后端根据const { username, password } = ctx.request.body;来获取请求体内数据，再通过用户名将数据库中的用户名对应的密码与请求体中的密码对比，对比成功就返回用户名与200状态码，前端根据返回的值来进行操作就行，不必赘述。

对于请求体的类型效验以及存在检查什么的也不赘述了。

```ts
import cloud from '@lafjs/cloud';

export default async function (ctx: FunctionContext) {
  try {
    // 从请求体中获取用户名和密码
    const { username, password } = ctx.request.body;

    // 校验请求参数
    if (!username || typeof username !== 'string') {
      return {
        code: 400,
        message: 'Invalid username. Username must be a non-empty string.'
      };
    }

    if (!password || typeof password !== 'string') {
      return {
        code: 400,
        message: 'Invalid password. Password must be a non-empty string.'
      };
    }

    // 获取 MongoDB 实例
    const db = cloud.mongo.db;

    // 指定集合名称
    const collectionName = 'userlist'; // 替换为您的用户集合名称
    const collection = db.collection(collectionName);

    // 根据 username 查询用户信息
    const user = await collection.findOne({ username });

    if (!user) {
      return {
        code: 401,
        message: 'Invalid credentials. Please check your username and password.'
      };
    }

    // 验证密码
    // 在实际应用中，密码应该使用加密算法（如 bcrypt）进行存储和验证
    if (user.password !== password) {  //如果user在集合中找到的密码与输入的密码不相同就返回401
      return {
        code: 401,
        message: 'Invalid credentials. Please check your username and password.'
      };
    }

    // 如果验证成功，返回用户信息
    return {
      code: 200,
      user: {
        username: user.username,
        // 其他用户信息可以根据需要返回
      },
      message: 'Login successful'
    };

  } catch (error) {
    //异常处理
    console.error('Error during login:', error);
    return {
      code: 500,
      message: 'Internal server error'
    };
  }
}
```