# 某些有用的

## @error处理异常，调用函数

在 Vue 3 中，`@error` 是用于监听 DOM 元素或组件上的错误事件的一种方式。当绑定的元素或组件发生错误时，可以触发一个回调函数来处理异常。以下是关于 `@error` 处理异常和调用函数的详细解释和示例。

### **1. 使用 `@error` 监听 DOM 元素的错误事件**
`@error` 可以直接绑定到 HTML 元素（如 `<img>`、`<video>` 等）上，用于捕获加载失败或其他错误事件。

#### 示例：
```vue
<template>
  <div>
    <img :src="imageUrl" @error="handleError" alt="示例图片" />
  </div>
</template>

<script>
export default {
  data() {
    return {
      imageUrl: 'https://example.com/image.jpg',
    };
  },
  methods: {
    handleError(event) {
      console.error('图片加载失败:', event);
      // 可以在这里执行其他逻辑，例如显示默认图片
      event.target.src = 'https://example.com/default.jpg';
    },
  },
};
</script>
```

### **2. 使用 `@error` 监听组件的错误事件**
对于 Vue 组件，可以通过 `@error` 监听子组件抛出的错误事件。

#### 示例：
```vue
<template>
  <div>
    <ChildComponent @error="handleError" />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: { ChildComponent },
  methods: {
    handleError(error) {
      console.error('子组件发生错误:', error);
      // 可以在这里执行其他逻辑，例如显示错误提示
    },
  },
};
</script>
```

### **3. 使用 `errorCaptured` 生命周期钩子**
`errorCaptured` 是 Vue 3 提供的一个生命周期钩子，用于捕获子组件的错误。它可以在组件内部捕获错误并处理。

#### 示例：
```vue
<template>
  <div>
    <ChildComponent />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: { ChildComponent },
  errorCaptured(err, instance, info) {
    console.error('捕获到子组件错误:', err, info);
    return false; // 返回 false 阻止错误向上传播
  },
};
</script>
```

### **4. 全局错误处理**
Vue 3 提供了 `app.config.errorHandler` 配置选项，用于全局捕获未处理的错误。

#### 示例：
```javascript
import { createApp } from 'vue';
import App from './App.vue';

const app = createApp(App);

app.config.errorHandler = (err, instance, info) => {
  console.error('全局错误捕获:', err, info);
  // 可以在这里记录错误或通知用户
};

app.mount('#app');
```

### **5. 异步错误处理**
对于异步操作（如 API 请求），可以使用 `try...catch` 或 `Promise.catch` 来捕获错误。

#### 示例：
```vue
<template>
  <div>
    <button @click="loadData">加载数据</button>
  </div>
</template>

<script>
export default {
  methods: {
    async loadData() {
      try {
        const data = await this.fetchData();
        console.log('数据加载成功:', data);
      } catch (error) {
        console.error('数据加载失败:', error);
        // 可以在这里显示用户友好的错误信息
      }
    },
    async fetchData() {
      throw new Error('模拟的网络错误');
    },
  },
};
</script>
```

### **6. 使用 `ErrorBoundary` 组件**
`ErrorBoundary` 是一种封装错误处理的组件模式，用于捕获子组件的错误并显示友好的错误页面。

#### 示例：
```vue
<!-- ErrorBoundary.vue -->
<template>
  <div>
    <slot v-if="!hasError"></slot>
    <div v-else>
      <h1>发生错误</h1>
      <p>请刷新页面或稍后再试。</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      hasError: false,
    };
  },
  errorCaptured(err) {
    this.hasError = true;
    return false; // 阻止错误向上传播
  },
};
</script>
```

使用时：
```vue
<template>
  <ErrorBoundary>
    <HeavyComponent />
  </ErrorBoundary>
</template>

<script>
import ErrorBoundary from './ErrorBoundary.vue';
import HeavyComponent from './HeavyComponent.vue';

export default {
  components: { ErrorBoundary, HeavyComponent },
};
</script>
```

### **总结**
在 Vue 3 中，`@error` 是一种简单而强大的方式，用于监听和处理 DOM 元素或组件的错误事件。结合 `errorCaptured`、`app.config.errorHandler` 和 `try...catch` 等机制，可以实现从局部到全局的错误处理，确保应用的稳定性和用户体验。

## :class动态绑定字样式

:class="{子样式名: 展示该样式的条件}"

```vue
 <div class="pagination" v-if="totalPages > 0">
            <button  :disabled="currentPage === 1" @click="prevPage" ><</button>
            <button @click="changePage($event)" :class="{ active: showPage === currentPage || inpval == showPage}">{{ showPage }}</button>
            <button @click="changePage($event)" v-if="showPage + 1 <= totalPages"
                :class="{ active: currentPage === showPage + 1 || inpval == showPage+1}">{{ showPage + 1 }}</button>
            <button @click="changePage($event)" v-if="showPage + 2 <= totalPages"
                :class="{ active: currentPage === showPage + 2 || inpval == showPage+2}">{{ showPage + 2 }}</button>
            <button @click="changePage($event)" v-if="showPage + 3 <= totalPages"
                :class="{ active: currentPage === showPage + 3 || inpval == showPage+3}">{{ showPage + 3 }}</button>
            <!-- <span>第 {{ currentPage }} 页 / 共 {{ totalPages }} 页</span> -->
            <button  :disabled="currentPage === totalPages" @click="nextPage">></button>
            <div> 
              <input type="text" style="width: 60px; " v-model="inpvals"> <button @click="gotoPage">Go</button>
            </div>
        </div>
```

然后样式部分

```css
/* 添加一个简单的 active 状态样式 */
button.active {
    background-color: #6eb9fb;
    /* 绿色背景 */
    color: white;
    /* 白色文字 */
}
```

## v-if 的巧用

app.vue文件中，在各个路由中，只有当不是登录注册页面时才展示侧边栏

```vue
<template>
  <div class="app-container">
    <!-- 只在非登录/注册/找回密码页面显示侧边栏 -->
    <Sidebar v-if="shouldShowSidebar()" />
    
    <div class="main-content" :class="{ 'with-sidebar': shouldShowSidebar() }">
      <router-view v-slot="{ Component }">
        <transition name="fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </div>
  </div>
</template>
<script>
// 判断当前路由是否需要显示侧边栏
const shouldShowSidebar = () => {
  const publicRoutes = ['Login', 'Register', 'ForgotPassword'];
  return !publicRoutes.includes(router.currentRoute.value.name as string);
};</script>
```

## flex :1

展示侧边栏后剩余空间才是给各个路由对应文件用的

这样才能正确展示除了侧边栏之外的内容

```css
.main-content {
  flex: 1;
  overflow-y: auto;
  transition: all 0.3s ease;
}

```

`flex: 1;` 是 CSS `flex` 布局中一个简写的样式属性，主要用来定义子元素在容器中的伸缩行为。以下是关于它的详细解释和用法示例。

### **`flex` 属性的定义**
`flex` 是 `flex-grow`、`flex-shrink` 和 `flex-basis` 的简写形式，分别定义元素在弹性容器中的增长、收缩和基准大小。

- **`flex-grow`**：定义子元素如何分配弹性容器中的多余空间。值为数字，默认 0（不增长）。值越大，增长越快。
- **`flex-shrink`**：定义子元素如何缩小以适应弹性容器中的空间不足。值为数字，默认 1（允许缩小）。值越大，缩小越多。
- **`flex-basis`**：定义子元素在主轴方向上的初始大小（基础大小）。默认值为 `auto`，指的是根据内容自动调整大小。

### **`flex: 1;` 的含义**
`flex: 1;` 是一个简写，相当于：
```css
flex-grow: 1;
flex-shrink: 1;
flex-basis: 0;
```
也就是说，`flex: 1;` 表示：
1. 子元素将占据弹性容器中所有可用空间（`flex-grow: 1`），并且
2. 子元素可以被缩小（`flex-shrink: 1`），
3. 其初始大小为基础大小 0（`flex-basis: 0`）。

### **示例**
假设有一个弹性的容器（`display: flex;`），里面有多个子元素：
```html
<div class="container">
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
</div>
```

### **样式**
```css
.container {
  display: flex;
  width: 100%;
  border: 1px solid #ccc;
}

.item {
  flex: 1;
  border: 1px solid #666;
  padding: 20px;
  text-align: center;
}
```

### **效果**
- **父容器宽度为 100%**：整个容器占据父级的宽度。
- **三个子元素**（Item 1、Item 2、Item 3）会平分父容器的可用空间：
  - 每个子元素的宽度为 `100% / 3 ≈ 33.33%`。
  - 所有子元素的高度会自动调整以适应父容器的高度（如果父容器没有固定高度，子元素的高度会根据内容自动调整）。

### **间距和内容对齐**
如果子元素内容较短，`flex: 1;` 会使它们在横向方向上平分空间。如果内容较长，`flex-shrink: 1;` 会使它们适当缩小以适应容器宽度。

### **其他情况**
假设父容器宽度为 600px，子元素中有两个：
```html
<div class="container">
  <div class="item">Item A</div>
  <div class="item">Item B</div>
</div>
```

样式：
```css
.item {
  flex: 1;
}
```

结果：
- Item A 和 Item B 各占据 300px 的宽度（平分 600px 的父容器宽度）。

### **小结**
`flex: 1;` 是一种简单而强大的布局方式，适用于需要子元素平分容器空间的场景。通过调整 `flex-grow` 和 `flex-basis`，可以实现更复杂的布局效果。



## 去除按钮焦点边框

在点击按钮之后，由于焦点在按钮上，可以利用css去除按钮焦点边框

在style.css文件中定义全局的按钮样式

```css
button:focus {
    //去除焦点边框
  outline: none; 
}
```

隐藏侧边栏滚动条

```css
*{
  /* 隐藏侧边栏的滚动条 */
  scrollbar-width: none;
}
```



## 组件之间传参数

假设我现在在组件ModleFile，我现在点击按钮之后会跳转到另外一个组件并将筛选器的条件应用到另外一个组件，那么在ModleFile 文件中应该这样写：

在路由跳转的时候带上query参数，这个参数是一个对象

```ts
// 跳转到文件管理页面并应用筛选条件
        const goToFileManage = (template: TemplateFile) => {
            router.push({
                path: '/filemanage',
                query: {
                    name: template.name,
                    author: template.createdBy,
                    date: template.modifyDatetime,
                }
            });
        };
```

那么在另外一个文件中应该在组件挂载的时候就检查route路由器里面的参数，如果有就对应赋值到对应的筛选栏

```ts

        // 检查URL参数，如果有则应用筛选条件
        onMounted(() => {
            const queryId = route.query.id as string;
            const queryName = route.query.name as string;
            const queryAuthor = route.query.author as string;
            const queryCategory = route.query.category as string;
            const queryModifyDate = route.query.modifyDate as string;

            if (queryId) filters.value.id = queryId;
            if (queryName) filters.value.templateName = queryName;
            if (queryAuthor) filters.value.author = queryAuthor;
            if (queryCategory) filters.value.category = queryCategory;
            if (queryModifyDate) filters.value.modifyDate = queryModifyDate;            
        });
```



## 接口定义来ref类型

比如有这么一个类型接口

```ts
// 用户信息接口
export interface UserInfo{
  id: number,
  username:string,
  email:string,
  organization:string,
  avatarUrl:string
}

```

我们现在想要定义一个可变的ref类型变量，应用上这个类型接口，，那么应该这样写：

```ts
const userInfo = ref<UserInfo>({
    id: 21233,
    username: '张伟',
    email: 'doctor@126.com',
    organization: '技术部',
    avatarUrl: "https://tse3-mm.cn.bing.net/th/id/OIP-C.JCEcaQJVR_vC2kgt6BGZlAAAAA?rs=1&pid=ImgDetMain"
});
```



## 时间戳处理

后端传来的时间是数字类型的时间戳，自然前端要定义函数去处理

```ts
export default function (timestamp: number): string{
    // 创建 Date 对象
    const date = new Date(timestamp);

    // 获取年月日
    const year = date.getFullYear();
    const month = date.getMonth() + 1; // getMonth() 返回 0-11，需要加 1
    const day = date.getDate();

    // 获取小时和分钟
    const hours = date.getHours();
    const minutes = date.getMinutes();

    // 判断是 AM 还是 PM
    const ampm = hours >= 12 ? 'PM' : 'AM';

    // 将小时转换为 12 小时制
    const hours12 = hours % 12 || 12; // 如果是 0 点，显示为 12 AM

    // 格式化分钟，确保是两位数
    const formattedMinutes = minutes.toString().padStart(2, '0');

    // 返回格式化的字符串
    return `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')} ${hours12}:${formattedMinutes} ${ampm}`;
};
```

然后在对应的组件页面引入这个工具函数

```ts
import formatDate from "../tools/formatDate";
```

同时通过spilt进行自定义展示

```vue
<td>{{ formatDate(template.updateTime).split(" ")[0] }}
                            <div style="font-size: smaller; color: gray;">{{ formatDate(template.updateTime).split(" ")[1]}} {{ formatDate(template.updateTime).split(" ")[2]}} 
                            </div>
</td>
```

## 文件上传

在Vue3项目中实现文件上传到后端，并且前端需要同时传递`userId`，可以按照以下步骤进行：

### 1. 页面构建
使用`<input type="file">`标签创建文件选择器，供用户选择要上传的文件。同时，确保你有获取`userId`的逻辑（例如从Vuex、Pinia状态管理中获取，或者从API响应中获取）。

```vue
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <button @click="uploadFile">上传</button>
  </div>
</template>
```

### 2. 文件选择与处理
监听文件选择事件，获取用户选择的文件。同时，获取`userId`并将其与文件一起封装到`FormData`对象中。

```javascript
<script setup>
import { ref } from 'vue';
import axios from 'axios';

const selectedFile = ref(null);
const userId = ref('12345'); // 假设从某个地方获取到的 userId

const handleFileChange = (event) => {
  const file = event.target.files[0];
  if (file) {
    selectedFile.value = file;
  }
};
</script>
```

### 3. 文件上传逻辑
使用HTTP客户端（如axios）将封装好的文件数据和`userId`发送到后端API。设置请求头为`multipart/form-data`，以确保文件能正确上传。

```javascript
const uploadFile = async () => {
  if (!selectedFile.value) return;

  const formData = new FormData();
  formData.append('file', selectedFile.value);
  formData.append('userId', userId.value); // 将 userId 添加到 formData 中

  try {
    const response = await axios.post('/api/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    console.log('上传成功:', response.data);
  } catch (error) {
    console.error('上传失败:', error);
  }
};
```

### 4. 与后端交互
确保后端API能够接收`multipart/form-data`格式的请求，并正确处理上传的文件和`userId`。例如，使用Express和multer中间件来处理文件上传。

```javascript
const express = require('express');
const multer = require('multer');
const app = express();
const upload = multer({ dest: 'uploads/' });

app.post('/api/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).send({ error: '请上传一个文件' });
  }
  const userId = req.body.userId; // 获取 userId
  console.log('上传的文件:', req.file);
  console.log('用户ID:', userId);
  res.send({ url: req.file.path, filename: req.file.originalname, userId });
});
```

### 5. 注意事项
- **文件格式与大小限制**：在前端对文件进行校验，限制上传的文件格式和大小，提升用户体验。
- **上传进度显示**：利用axios的`onUploadProgress`方法，向用户展示上传进度。
- **错误处理**：对上传过程中可能出现的错误进行处理，如网络问题、服务器错误等，及时向用户反馈。

### 扩展功能
- **多文件上传**：如果需要支持多文件上传，可以将`<input type="file">`的`multiple`属性设置为`true`，并在`handleFileChange`中处理多个文件。
- **文件预览**：在上传之前，可以使用`URL.createObjectURL(file)`方法对文件进行预览。
- **取消上传**：如果需要支持取消上传功能，可以使用axios的`CancelToken`。

通过以上步骤，就可以在Vue3项目中实现文件上传到后端，并同时传递`userId`的功能。
