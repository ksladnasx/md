# Day 1 背包问题

## 01背包问题

> 有一个箱子容量为 V*V*，同时有 n*n* 个物品，每个物品有一个体积。
>
> 现在从 n*n* 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

***DP核心：找变量之间的状态转移方程***

代码：

```python
def knapsack(weights, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)

    for i in range(n):
        for j in range(capacity, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 修正状态转移方程

    return capacity - dp[capacity]  # 返回最小剩余空间


if __name__ == '__main__':
    V = int(input())
    n = int(input())
    vlist = []
    for i in range(n):
        vlist.append(int(input()))
    print(knapsack(vlist, V))

```

双重循环这段代码是解决0-1背包问题的核心部分，它的作用是通过动态规划逐步填充一个一维数组 `dp`，以找到在给定容量下能够装入的最大体积。以下是对这段代码的详细解释：

------

### 代码结构

Python复制

```python
for i in range(n):  # 遍历所有物品
    for j in range(capacity, weights[i] - 1, -1):  # 从大到小遍历背包容量
        dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 状态转移方程
```

------

### 1. **外层循环：遍历物品**

Python复制

```python
for i in range(n):
```

- 这个循环的作用是逐个考虑每一个物品。
- `n` 是物品的总数，`i` 是当前考虑的物品的索引。
- 每次循环处理一个物品，决定是否将其加入背包。

------

### 2. **内层循环：遍历背包容量**

Python复制

```python
for j in range(capacity, weights[i] - 1, -1):
```

- 这个循环的作用是考虑当前物品是否能加入到不同容量的背包中。
- `j` 表示当前背包的容量，从 `capacity`（背包的最大容量）开始，逐步减少到 `weights[i]`。
- **为什么从大到小遍历？**
  - 如果从大到小遍历，每次更新 `dp[j]` 时，`dp[j - weights[i]]` 是基于之前状态的值（即未考虑当前物品 `i` 的状态）。这样可以避免重复使用同一个物品。
  - 如果从小到大遍历，`dp[j - weights[i]]` 可能已经被更新过，这会导致同一个物品被多次使用，从而变成完全背包问题。

------

### 3. **状态转移方程**

Python复制

```python
dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
```

- 这是动态规划的核心部分，用于更新 `dp[j]` 的值。

- `dp[j]` 表示在背包容量为 `j` 的情况下，能够装入的最大体积。

- 状态转移方程的含义是：

  - 如果不选择当前物品 `i`，则背包容量为 `j` 时的最大体积仍然是 `dp[j]`。
  - 如果选择当前物品 `i`，则背包容量为 `j` 时的最大体积是 `dp[j - weights[i]] + weights[i]`，即在容量为 `j - weights[i]` 的情况下加上当前物品的体积。

- 最终，`dp[j]` 的值是两种情况中的最大值：

  Python复制

  ```python
  dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
  ```

------

### 4. **代码的执行过程**

假设背包容量为 `V`，物品体积为 `[w1, w2, ..., wn]`，以下是代码的执行过程：

1. 初始化 `dp` 数组，`dp[0] = 0`（容量为0时，最大体积为0），其余位置初始化为0。
2. 遍历每个物品 `i`：
   - 对于每个物品，从大到小遍历背包容量 `j`。
   - 对于每个容量 `j`，如果当前物品 `i` 的体积 `weights[i]` 小于等于 `j`，则考虑是否将物品 `i` 放入背包。
   - 更新 `dp[j]` 为两种情况的最大值：
     - 不放入物品 `i`：`dp[j]` 保持不变。
     - 放入物品 `i`：`dp[j] = dp[j - weights[i]] + weights[i]`。
3. 最终，`dp[capacity]` 表示在背包容量为 `capacity` 的情况下，能够装入的最大体积。

------

### 5. **输出结果**

最终结果是 `capacity - dp[capacity]`，表示背包的最小剩余空间。

------

### 示例

假设背包容量为 `V = 10`，物品体积为 `[3, 4, 5]`，以下是代码的执行过程：

1. 初始化 `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`。
2. 遍历第一个物品（体积为3）：
   - 更新 `dp[3]` 到 `dp[10]`：
     - `dp[3] = max(dp[3], dp[0] + 3) = 3`
     - `dp[4] = max(dp[4], dp[1] + 3) = 3`
     - ...
     - `dp[10] = max(dp[10], dp[7] + 3) = 3`
3. 遍历第二个物品（体积为4）：
   - 更新 `dp[4]` 到 `dp[10]`：
     - `dp[4] = max(dp[4], dp[0] + 4) = 4`
     - `dp[7] = max(dp[7], dp[3] + 4) = 7`
     - ...
4. 遍历第三个物品（体积为5）：
   - 更新 `dp[5]` 到 `dp[10]`：
     - `dp[5] = max(dp[5], dp[0] + 5) = 5`
     - `dp[10] = max(dp[10], dp[5] + 5) = 10`
5. 最终，`dp = [0, 0, 0, 3, 4, 5, 3, 7, 5, 8, 10]`。
6. 输出结果：`10 - dp[10] = 0`。

------

通过这段代码，我们能够动态地计算出在给定容量下能够装入的最大体积，从而求出最小剩余空间。

## 01背包问题（加上价值权重）

> ```
> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
> 如果你是辰辰，你能完成这个任务吗？
> ```

具体看代码注释：

```python
def knapsack(value, weight, capacity):
    n = len(value)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]  # 实际长度为容量加1（要考量容量为0的情况）
    # 0行和0列一定为0
    for i in range(1, n + 1):  # 要添加的物品价值为i时(按行遍历)
        for j in range(1, capacity + 1):  # 遍历每一种容量的背包 j为容量
            if weight[i - 1] <= j:
                # 当容量足够加入该物品时,进行对比
                """如果没有这个物品介入时,同为j容量的背包能装得的物品最大价值dp[i - 1][j]
                以及如果选择装入这个物品(value[i - 1])与剩下容量能装入的最大价值dp[i - 1][j - weight[i - 1]]的和
                在两者之间比较最大值取就行
                """
                dp[i][j] = max(value[i - 1] + dp[i - 1][j - weight[i - 1]], dp[i - 1][j])
            else:  # 当要添加的物品加不进背包时候,最优解就是同容量背包不加这个物品的时候的最优解
                dp[i][j] = dp[i - 1][j]

    # 最后一行的capacity列的值就是所求的最优解, 即容量为capacity的背包能装入的物品最大价值
    return dp[n][capacity]


if __name__ == '__main__':
    T, M = map(int, input().split(' '))
    # T就是背包容量
    tlist = []  # 存每个物品的耗时(即物品需要的背包容量)
    mlist = []  # 存每个物品价值
    for i in range(M):
        t, m = map(int, input().split(' '))
        tlist.append(t)
        mlist.append(m)

    print(knapsack(mlist, tlist, T))
```

# Day2 快速幂算法

> 快速幂算法（也称为“快速指数运算”或“快速幂取模”）是一种高效的算法，用于计算 *a**b*mod*m*，即计算 *a* 的 *b* 次幂对 *m* 取模的结果。该算法的核心思想是通过将指数 *b* 分解为二进制形式，从而将问题分解为若干个较小的幂次运算，大大减少了计算量。快速幂算法的核心是每个数的n次方，则分解为数的形式，如2的7次方可以分解为2的1次方乘以2的2次方乘以2的四次方.而对应的二进制中为1位是有规律的。

### 1. **快速幂算法的基本原理**

快速幂算法利用了指数的二进制表示和幂的性质。具体来说，任何整数 *b* 都可以表示为二进制形式，例如：

*b*=*b**k*⋅2*k*+*b**k*−1⋅2*k*−1+⋯+*b*1⋅21+*b*0⋅20

其中 *b**i* 是二进制位（0 或 1）。因此：

*a**b*=*a**b**k*⋅2*k*+*b**k*−1⋅2*k*−1+⋯+*b*1⋅21+*b*0⋅20

根据幂的性质，可以进一步分解为：

*a**b*=(*a*2*k*)*b**k*⋅(*a*2*k*−1)*b**k*−1⋅⋯⋅(*a*21)*b*1⋅(*a*20)*b*0

由于 *b**i* 只能是 0 或 1，因此 *a*2*i* 只有在 *b**i*=1 时才会被乘入最终结果。

### 2. **快速幂算法的实现步骤**

快速幂算法的核心是通过循环逐步计算 *a*2*i*，并根据 *b**i* 的值决定是否将其乘入最终结果。具体步骤如下：

#### 输入：

- *a*：基数
- *b*：指数
- *m*：模数

#### 输出：

- *a**b*mod*m*

#### 算法步骤：

1. 初始化结果为 1，即 result=1。
2. 将基数 *a* 对模数 *m* 取模，即 *a*=*a*mod*m*。
3. 遍历指数 *b* 的每一位（从最低位到最高位）：
   - 如果当前位为 1（即 *b**i*=1），则将当前的 *a*2*i* 乘入结果，并对 *m* 取模。
   - 将基数 *a* 平方，并对 *m* 取模，即 *a*=(*a*×*a*)mod*m*。
   - 将指数 *b* 右移一位（相当于除以 2）。
4. 当指数 *b* 为 0 时，循环结束，返回结果。

### 3. **Python 实现**

以下是快速幂算法的 Python 实现：

```python
def Binexp(a,n):
    r = 1
    while n > 0:
        if n % 2 == 1:  #如果n的二进制最后一位是1，则乘入r
            r *= a
        a *= a  #a更新到下一个为偶次方的值上
        n //= 2  #n //= 2的含义就是将n的二进制的最后一位消灭掉
    return r
```

当然，可以将其中的一些运算换成位运算，与运算

```python
def Binexp(a, n):
    r = 1
    while n > 0:
        if n & 1:  #n & 1表示n与1的二进制做位运算，只看最后一位是否相等，相等说明n的二进制最后一位是1
            r *= a
        a *= a
        n >>= 1  # n 对2整除并向下取整等效于将n的二进制右移一位
    return r
```



### 4. **快速幂算法的优势**

- **时间复杂度**：快速幂算法的时间复杂度为 *O*(log*b*)，因为每次循环都将指数 *b* 减半。
- **空间复杂度**：快速幂算法的空间复杂度为 *O*(1)，因为它只需要常数级的额外空间。
- **适用场景**：特别适用于大整数的幂运算和模运算，例如在密码学和数论问题中。

### 5. 取模

> 小蓝想要构造出一个长度为10000 的数字字符串，有以下要求：
>
> 1) 小蓝不喜欢数字 0 ，所以数字字符串中不可以出现 0 ；
> 2) 小蓝喜欢数字 3 和 7 ，所以数字字符串中必须要有 3 和 7 这两个数字。
>
> 请问满足题意的数字字符串有多少个？这个数字会很大，你只需要输出其对 109 + 7 取余后的结果。

### 原理：<img src="C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250121125032521.png" alt="image-20250121125032521" style="zoom:50%;" />

在适当位置加入取模运算即可

a的n次方对m取模

代码：

```python
def qumo(a, n, m):
    a = a % m  # 将基数 a 对模数 m 取模，减少后续计算中的数值大小
    r = 1      # 初始化结果 r 为 1（因为任何数的 0 次幂都是 1）
    while n > 0:  # 当指数 n 大于 0 时继续循环
        if n & 1 == 1:  # 如果 n 的二进制最低位是 1
            r = (r * a) % m  # 将当前的 a 乘入结果 r，并对 m 取模
        a = (a * a) % m  # 将 a 平方，并对 m 取模
        n >>= 1  # 将 n 右移一位（相当于 n = n // 2）
    return r  # 返回最终结果
```

按为了求解这个问题，我们需要计算满足以下条件的长度为10000的数字字符串的数量：

1. 字符串中不能包含数字0。
2. 字符串中必须包含数字3和7。

首先，我们计算不包含数字0的长度为10000的数字字符串的总数。由于每个位置可以是1到9中的任意一个数字，所以总共有 910000 个这样的字符串。

接下来，我们需要减去不包含数字3或不包含数字7的字符串数量。不包含数字3的字符串中，每个位置可以是1到9中除了3以外的8个数字，所以总共有 810000 个这样的字符串。同样，不包含数字7的字符串也有 810000 个。

但是，我们减去的太多了，因为那些既不包含数字3也不包含数字7的字符串被减去了两次。所以，我们需要加上既不包含数字3也不包含数字7的字符串数量。这样的字符串中，每个位置可以是1到9中除了3和7以外的7个数字，所以总共有 710000 个这样的字符串。

因此，满足条件的字符串数量为： 910000−2⋅810000+710000

由于这个数字非常大，我们需要对 109+7 取余。我们可以使用快速幂算法来计算 910000mod(109+7)，810000mod(109+7)，和 710000mod(109+7)

```python
print((qumo(9, 10000,10**9+7)-2*qumo(8,10000,10**9+7)+qumo(7,10000,10**9+7))%(10**9+7))
```



## 6. 斐波那契的第i项

原理：

<img src="C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250121130923474.png" alt="image-20250121130923474" style="zoom:50%;" />

所以，只需要计算出矩阵的n次方就可以得到第n项的值

最重要的就是计算矩阵的n次方

```python
import numpy as np
def fibonacci3(n):
    A = np.array([[0, 1], [1, 1]], dtype=np.object_)
    R = np.eye(A.shape[0], dtype=np.object_)
    while n > 0:
        if n & 1:
            R = np.dot(R, A)
        A = np.dot(A, A)
        n >>= 1
    return R[1,0]

```

 A = np.array([[0, 1], [1, 1]], dtype=np.object_)创建一个矩阵A

R是初始化一个基于A的形状的0矩阵

返回的R[1,0]就是我们需要的值

### 6. **总结**

快速幂算法是一种高效且实用的算法，通过将指数分解为二进制形式，利用幂的性质和模运算的性质，大大减少了计算量。它不仅适用于大整数的幂运算，还可以在模运算中高效地计算结果，是解决相关问题的重要工具。

## 补充：对于py中的`np.dot` 

`np.dot` 是 NumPy 库中的一个函数，用于计算两个数组的点积（dot product）。它是一个非常强大的函数，可以处理向量、矩阵以及更高维度数组的乘法运算。以下是对 `np.dot` 的详细解释和一些常见用法。

------

### 1. **点积的基本概念**

点积（dot product）是线性代数中的一个基本运算，用于计算两个向量的乘积。对于两个向量 a 和 b，它们的点积定义为：

a⋅b=i=1∑naibi

其中 ai 和 bi 是向量的对应元素。

对于矩阵，点积通常表示为矩阵乘法。如果 A 是一个 m×n 矩阵，B 是一个 n×p 矩阵，那么它们的点积 C=A⋅B 是一个 m×p 矩阵，其中每个元素 Cij 由以下公式计算：

Cij=k=1∑nAikBkj

------

### 2. **`np.dot` 的用法**

`np.dot` 可以处理多种类型的数组，包括一维数组（向量）、二维数组（矩阵）以及更高维度的数组。它的行为会根据输入数组的维度而有所不同。

#### 2.1 **向量点积**

如果输入是两个一维数组，`np.dot` 计算它们的点积。

Python复制

```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = np.dot(a, b)
print(result)  # 输出：32 (1*4 + 2*5 + 3*6)
```

#### 2.2 **矩阵乘法**

如果输入是两个二维数组，`np.dot` 计算它们的矩阵乘积。

Python复制

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

result = np.dot(A, B)
print(result)
# 输出：
# [[19 22]
#  [43 50]]
```

#### 2.3 **多维数组**

对于更高维度的数组，`np.dot` 的行为会更复杂。它会沿着最后一个轴进行点积运算。

Python复制

```python
A = np.random.rand(2, 3, 4)
B = np.random.rand(2, 4, 5)

result = np.dot(A, B)
print(result.shape)  # 输出：(2, 3, 5)
```

------

### 3. **`np.dot` 与 `@` 运算符**

从 Python 3.5 开始，`@` 运算符被引入，用于表示矩阵乘法。在 NumPy 中，`@` 运算符与 `np.dot` 的行为相同。

Python复制

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

result = A @ B  # 等价于 np.dot(A, B)
print(result)
# 输出：
# [[19 22]
#  [43 50]]
```

------

### 4. **注意事项**

1. **维度匹配**：
   - 对于向量点积，两个数组的长度必须相同。
   - 对于矩阵乘法，第一个矩阵的列数必须等于第二个矩阵的行数。
   - 对于更高维度的数组，最后一个轴的维度必须匹配。
2. **性能优化**：
   - NumPy 的 `np.dot` 是高度优化的，底层使用了 BLAS（Basic Linear Algebra Subprograms）库，因此在处理大规模数据时非常高效。
3. **与 `np.matmul` 的区别**：
   - `np.dot` 和 `np.matmul` 在处理二维数组时行为相同，但在处理一维数组时有所不同。`np.matmul` 会将一维数组视为二维数组（列向量或行向量），而 `np.dot` 则直接计算点积。

------

### 5. **总结**

`np.dot` 是 NumPy 中用于计算点积和矩阵乘法的核心函数。它支持多种输入维度，并且在性能上经过高度优化。如果你需要进行线性代数运算，`np.dot` 是一个非常强大的工具。

# Day3

学小程序去了.......

# Day4 贪心

## 1.分组问题

> ## 题目描述
>
> 有 n*n* 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 R*R* 和下界 L (L≤R)*L* (*L*≤*R*)，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 N*N* 组学生的人数都在 [L,R][*L*,*R*] 中。
>
> ## 输入格式
>
> 第一行一个整数 n*n*，表示学生组数；
>
> 第二行 n*n* 个整数，表示每组的学生个数；
>
> 第三行两个整数 L,R*L*,*R*，表示下界和上界。
>
> ## 输出格式
>
> 一个数，表示最少的交换次数，如果不能满足题目条件输出 −1−1。

### **算法思路**

1. **可行性检查：**
   - 首先，计算所有组的总学生数 S。
   - 检查 S 是否满足 n **L≤S≤n* *R。如果不满足，直接返回 -1，因为无法通过移动学生满足条件。
2. **计算调整需求：** 
   - 遍历每组学生人数 ai，计算每 组与范围 [L,R] 的偏差：
     - 如果 ai<L，则该组需要增加 L−ai 个学生，记为 **负偏差**（`deficit`）。
     - 如果 ai>R，则该组需要减少 ai−R 个学生，记为 **正偏差**（`excess`）。
3. **计算最小移动次数：**
   - 每次移动操作可以同时解决一个正偏差和一个负偏差（即从一个组移出一个学生，移到另一个组）。
   - 最小移动次数为 `max(deficit, excess)`，因为：
     - 如果 `deficit > excess`，则需要从其他组中分配额外的学生来满足需求。
     - 如果 `excess > deficit`，则需要将多余的 `excess` 分配到需要的学生中。
   - 如果 `deficit == excess`，则所有偏差都可以完美匹配，移动次数为 `deficit`。

### **关键点**

1. **可行性检查**：确保总学生数 S 在理论上的可行范围内。
2. **偏差计算**：通过计算正偏差和负偏差，确定需要调整的学生数量。
3. **最小移动次数**：通过最大化正偏差和负偏差的匹配，最小化移动次数。

### **代码实现**

以下是完整的 Python 代码实现：

Python复制

```python
def min_moves_to_balance_groups(n, groups, L, R):
    # 计算总学生数
    total_students = sum(groups)
    
    # 检查是否可行
    if n * L > total_students or total_students > n * R:
        return -1  # 不可能满足条件

    # 初始化正偏差和负偏差
    excess = 0  # 需要移出的学生总数
    deficit = 0  # 需要移入的学生总数

    # 计算每个组的调整需求
    for group in groups:
        if group < L:
            deficit += L - group  # 负偏差
        elif group > R:
            excess += group - R  # 正偏差

    # 最小移动次数为正偏差和负偏差的最大值
    moves = max(deficit, excess)
    return moves

# 读取输入
n = int(input().strip())
groups = list(map(int, input().strip().split()))
L, R = map(int, input().strip().split())

# 调用函数并输出结果
result = min_moves_to_balance_groups(n, groups, L, R)
print(result)
```

### **示例**

#### 输入：

复制

```
2
10 20
10 15
```

#### 输出：

```
5
```

#### 解释：

- 第一组学生数为 10，不需要调整（10≥L）。
- 第二组学生数为 20，需要减少 5 个学生（20−R=5）。
- 最小移动次数为 5，即将 5 个学生从第二组移动到第一组。

### **总结**

这个算法的核心在于通过计算正偏差和负偏差，找到最小的移动次数来平衡所有组的学生人数。通过可行性检查和贪心策略，我们能够高效地解决这个问题，时间复杂度为 O(n)。

## 2.纸牌均分

> 有 N*N* 堆纸牌，编号分别为 1,2,…,N1,2,…,*N*。每堆上有若干张，但纸牌总数必为 N*N* 的倍数。可以在任一堆上取若干张纸牌，然后移动。
>
> 移牌规则为：在编号为 11 堆上取的纸牌，只能移到编号为 22 的堆上；在编号为 N*N* 的堆上取的纸牌，只能移到编号为 N−1*N*−1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
>
> 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。
>
> 例如 N=4*N*=4 时，44 堆纸牌数分别为 9,8,17,69,8,17,6。
>
> 移动 33 次可达到目的：
>
> - 从第三堆取 44 张牌放到第四堆，此时每堆纸牌数分别为 9,8,13,109,8,13,10。
> - 从第三堆取 33 张牌放到第二堆，此时每堆纸牌数分别为 9,11,10,109,11,10,10。
> - 从第二堆取 11 张牌放到第一堆，此时每堆纸牌数分别为 10,10,10,1010,10,10,10。
>
> ## 输入格式
>
> 第一行共一个整数 N*N*，表示纸牌堆数。
> 第二行共 N*N* 个整数 A1,A2,…,AN*A*1​,*A*2​,…,*A**N*​，表示每堆纸牌初始时的纸牌数。
>
> ## 输出格式
>
> 共一行，即所有堆均达到相等时的最少移动次数。

为了解决这个问题，我们需要找到一种方法，使得每堆纸牌的数量最终都相等，并且移动次数最少。我们可以通过以下步骤来实现：

1. **计算平均值**：首先，计算所有纸牌的总数，然后除以堆数 N，得到每堆纸牌最终应该有的平均数量。
2. **确定移动方向**：根据规则，纸牌只能移动到相邻的堆上。因此，我们需要从每堆纸牌的数量与平均值的差值出发，确定纸牌的移动方向。
3. **最小移动次数**：为了最小化移动次数，我们应优先考虑将纸牌从数量较多的堆移动到数量较少的堆，直到所有堆的数量都达到平均值。

### 解题步骤

1. **计算平均值**：

   平均值=N∑i=1NAi

2. **确定移动方向**：

   - 对于每堆纸牌，计算其与平均值的差值。
   - 如果某堆纸牌的数量大于平均值，需要将多余的纸牌移动到相邻的堆上。
   - 如果某堆纸牌的数量小于平均值，需要从相邻的堆上移动纸牌过来。

3. **最小移动次数**：

   - 从左到右遍历每堆纸牌，记录每堆纸牌与平均值的差值。
   - 使用一个变量 `balance` 来记录当前堆与前一堆的平衡状态。
   - 每次移动纸牌时，更新 `balance`，并增加移动次数。

### 代码实现

```python
def min_moves_to_equalize_cards(N, A):
    # 计算平均值
    total_cards = sum(A)
    average = total_cards // N

    # 初始化移动次数和平衡变量
    moves = 0
    balance = 0

    # 遍历每堆纸牌
    for i in range(N):
        # 计算当前堆与平均值的差值
        diff = A[i] - average

        # 更新平衡变量
        balance += diff

        # 如果平衡变量不为零，说明需要移动纸牌
        if balance != 0:
            moves += 1

    return moves

# 读取输入
N = int(input())
A = list(map(int, input().split()))

# 计算并输出最小移动次数
print(min_moves_to_equalize_cards(N, A))
```

### 示例

对于给定的示例 N=4 和 A=[9,8,17,6]：

1. **计算平均值**：

   平均值=49+8+17+6=10

2. **确定移动方向**：

   - 第一堆：9−10=−1（需要从第二堆移动 1 张纸牌）
   - 第二堆：8−10=−2（需要从第相邻堆移动 2 张纸牌）
   - 第三堆：17−10=7（需要移动 7 张纸牌到相邻堆）
   - 第四堆：6−10=−4（需要从第三堆移动 4 张纸牌）

3. **最小移动次数**：

   - 从第三堆移动 4 张纸牌到第四堆
   - 从第三堆移动 3 张纸牌到第二堆
   - 从第二堆移动 1 张纸牌到第一堆

总共需要 3 次移动。

### 输出：3

# Day5 递推

> 通过简单的暴力dfs递归方式，时间复杂度过高，虽然可以定义数组来记忆每次的结果，给暴力搜索数”减枝“，但是时间复杂度仍然很高。
>
> 递归的过程分为”递“和”归“，如果将递归的过程只保留”归“的过程，便可以大大降低时间复杂度。
>
> 这便是递推，下面简单演示一下斐波那契的优化
>
> 同时也是跳台阶问题



**DP核心：找变量之间的状态转移方程**

## 跳台阶问题

> n级台阶，一次可以选择跳一级或者两级，问有几种跳跃方式？

### 分析

自然是斐波那契数列，f(n)表示n级台阶的跳跃方式数，如果n级台阶，对于最后一跳，如果是跳一级，那跳跃方式数就是f(n-1)，如果是跳两级，跳跃方式数就是f(n-2)，那么最后一跳总共就这两种情况，则f[i] = f[i - 1] + f[i - 2]

###  代码

```python
# 简单的递归搜索加上记忆化搜索，时间复杂度仍然很高
def jump(n):
    # 如果n在记忆中，就直接返回
    if n in mem:
        return mem[n]
    if n == 1:
        sum = 1
    elif n == 2:
        sum = 2
    else:
        sum = jump(n - 1) + jump(n - 2)
    mem[n] = sum
    return sum


"""利用递归过程中的“推”的过程，便是基本的递推优化"""

"""注意，这里是优化时间"""
def optimized_jump(n):
    f = [0] * (n + 1)
    f[1] = 1
    f[2] = 2
    for i in range(3, n + 1):
        f[i] = f[i - 1] + f[i - 2]  # 这个递推公式也就是dfs的状态转移公式
    return f[n]


# 上面的代码也可以换成这种形式的写法，核心都是从小到大递推
"""注意，这里是对上面的函数优化空间"""
def optimized_jump2(n):
    if n == 1: return 1
    if n == 2: return 2
    newf = 0
    temp1 = 1
    temp2 = 2
    for i in range(3, n + 1):
        newf = temp1 + temp2
        temp1 = temp2
        temp2 = newf

    return newf


if __name__ == '__main__':
    mem = [0] * 100

    # 明显快了很多
    # print("Starting:" ,jump(400))
    # print("Starting:", optimized_jump(400))
    print("Starting:", optimized_jump2(300))

```

## 大盗阿福

> 阿福洗劫商店，不能同时洗劫相邻的两家商店，求最多能洗劫多少钱
>
> 输入第一行是商店数T，第二行T个数，表示每家商店的现金数目
>
> 输出能取得的最大金钱数

### 分析

该问题目前可以两中方式解决。T是商店数，moneyList是每个商店的金钱数，自然
$$
moneyList[T-1]就是最后一家的金钱数
$$


#### 背包

对于这个问题，自然而然可以联想到Day1的背包问题，要收益最大，就依次分析情况

定义函数max_money(T)表示有T家店铺时的最优解。

如果商店数只有一个（T == 1），那只洗劫它一个（moneyList[0]），如果有两个，就洗劫两者之中最大那个

如果大于两个的店铺，对于有第T家店铺的情况，就开始考虑，是直接使用有T-1家店铺情况时候的最优解（max_money(T - 1)），还是使用有T-2家店铺的时候的最优解，并且窃取这多出来的第T家店铺这个店铺（max_money(T - 2) + moneyList[T - 1]）。



```python
# 考虑01背包问题的解决方式
def max_money(T):
    if T == 1:
        return moneyList[0]
    if T == 2:
        return max(moneyList[0], moneyList[1])
    # moneylist[T-1]是最后一个店铺的金钱数，这里考虑的问题就是，如果多一个店铺，是在原有基础上保留，还是退回一个店铺选择窃取这个新出现的店铺
    return max(max_money(T - 2) + moneyList[T - 1], max_money(T - 1))
```

#### 递归

然后对于是递归，定义函数dfs(x)表示阿福正在考虑第x家店铺，递推的边界（结束条件）就是当x大于等于商店数，此时第x个商店不存在，就返回0。

> 注意这里有个小坑，moneyList[x-1]才是表示第x家店铺的金钱数，第一家店铺的金钱数是存在moneyList[0]的，别搞混了。

当x为1 的情况下，就考虑最大收益，是就洗劫第这家店铺（moneyList(x-1)），同时因为限制去考虑相隔一家的店铺(dfs（x+2）), 还是不洗这家店铺，去考虑相邻的那家店铺dfs(x + 1)。这两个取最大就行

倘若选择了dfs（x+2）+moneyList(x-1），那就说明了阿福已经洗劫了第x家店铺，因为要相隔一个的限制，阿福开始考虑对于第x+2家店铺，是洗劫它并去考虑它的下下家店铺，还是放弃它去考虑它相邻的那家店铺，以此递推下去，直到阿福考虑的第x家店铺并不存在，无法洗劫，现金为0.

```python
# 考虑递推优化的方式
"""当遇到第x家店铺时，考虑的是选择下一家（x+1）店铺dfs(x + 1)或者就选择这一家，那么下次考虑的就是第x+2家店铺dfs(x + 2) + moneyList[x]"""
def dfs(x):
    if x > T: return 0
    return max(dfs(x + 1), dfs(x + 2) + moneyList[x-1])
```

#### 记忆化搜索优化递归

自然直接递归的方式形成的搜索树是许多重复的，需要进行“减枝”的操作。那便要使用记忆化搜索

对于记忆化搜索，函数的形参要尽量少，对于不影响递归边界的参数就没必要传入函数，如moneyList，直接在main函数里面定义就行，python会自动处理为全局的变量，函数中可以直接读取使用。

定义记账本mem = [0] * (T + 1)，当考虑第x个店铺时，如果已经计算过最优解并存在mem中（mem[x]!=0）那便直接返回就行。如果没有再继续计算，将每次函数运行计算得到的结果存在sum中。

这里的mem[x]表示的就是对于T家店铺，如果只从第x家开始考虑，能取得的最大金钱数。

mem[1]相当于就是dfs(1)，表示的就是从第一家开始考虑，也就是考虑所有的T家店铺能得到的最大金钱数。

```python
mem = [0] * (T + 2)  #如此定义长度是为了防止x > T的情况出现，大于T的时候自然存0就行
def memSearch(x):
    if mem[x] != 0:
        return mem[x]
    if x > T:
        sums = 0
    else:
        sums = max(dfs(x + 1), dfs(x + 2) + moneyList[x - 1])
    mem[x] = sums
    return sums
```

#### **递推**

以上方法都只是利用“归”的方式来产生答案，那么我们完全可以避免那“递”的过程，直接进行递推。

f[i] 表示从第i个店铺开始洗劫能获取的最大现金数，其实跟mem[i]一个意思

f[i] = max(f[i + 1], f[i + 2] + moneyList[i - 1])表示 从第i个店铺开始能获取到的最大价值是两种情况中的最大值

第一张情况是洗劫第i个店铺，那就是从第i+2个店铺开始能获取的最大价值加上第i个店铺的价值f[i + 1], f[i + 2]

第二种情况是不洗劫第i个店铺，那么从第i个店铺开始能获取到的最大价值等于从第i+1个店铺开始能获取到的最大价值

注意这里f = [0] * (T + 3)是因为为了防止i==T 时 f[i + 2]不越界

```python
f = [0] * (T + 3)  # f[i] 表示从第i个店铺开始洗劫能获取的最大现金数
def recursFind(T):
    # 从T到1倒叙进行
    for i in range(T, 0, -1):
        f[i] = max(f[i + 1], f[i + 2] + moneyList[i - 1])
    return f[1]
```

#### 递推空间优化

我们只需要f列表中的一个值，而这个又是满足规律的，即T个商店能获取的最大价值是T-1个商店能获取的最大价值与T-2个商店能获取的最大价值同第T个商店的价值的最大值。

MaxMon[T] = max(MaxMon[T-1],MaxMon[T]+moneyList[i])

这便是状态转移方程。当前值只与前一个值和前前个值有关，那么定义三个变量，一个表示当前值（newf ），一个表示前一个值（temp1 ），另一个表示前前值（temp12），三个变量轮流更新就行。

```python
def recursFindPlus(T):
    newf = 0
    temp1 =0
    temp2 = 0
    for i in range(T):
        newf = max(temp1, temp2 + moneyList[i])
        temp2 = temp1
        temp1 = newf  #temp1始终存的是上一次的最优的结果，temp2存的是上上次的最优结果
        print("newf:",newf)
    return newf
```



#### 基本规律

<img src="C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250125214120080.png" alt="image-20250125214120080" style="zoom:33%;" />



### 完整代码

```python
# 考虑01背包问题的解决方式
def max_money(T):
    if T == 1:
        return moneyList[0]
    if T == 2:
        return max(moneyList[0], moneyList[1])
    # moneylist[T-1]是最后一个店铺的金钱数，这里考虑的问题就是，
    # 如果多一个店铺，是在原有基础上保留，还是退回一个店铺选择窃取这个新出现的店铺
    return max(max_money(T - 2) + moneyList[T - 1], max_money(T - 1))


# 考虑递归的方式
"""当遇到第x家店铺时，考虑的是选择下一家（x+1）店铺dfs(x + 1)或者就选择这一家，
那么下次考虑的就是第x+2家店铺dfs(x + 2) + moneyList[x]"""


def dfs(x):
    if x > T:
        return 0
    return max(dfs(x + 1), dfs(x + 2) + moneyList[x - 1])


# 记忆化搜索优化递归
def memSearch(x):
    if mem[x] != 0:
        return mem[x]
    if x > T:
        sums = 0
    else:
        sums = max(dfs(x + 1), dfs(x + 2) + moneyList[x - 1])
    mem[x] = sums
    return sums


# 倒叙的递推
def recursFind(T):
    # 从T到1倒叙进行
    for i in range(T, 0, -1):
        f[i] = max(f[i + 1], f[i + 2] + moneyList[i - 1])
    return f[1]


# 递推并且进行空间优化
def recursFindPlus(T):
    temp1 = 0
    temp2 = 0
    newf = 0
    for i in range(T):
        newf = max(temp1, temp2 + moneyList[i])
        temp2 = temp1
        temp1 = newf  # temp1始终存的是上一次的最优的结果，temp2存的是上上次的最优结果
        print("newf:", newf)
    return newf


if __name__ == '__main__':
    T = int(input())
    moneyList = list(map(int, input().split(" ")))
    
    print(max_money(T))
    
    print(dfs(1))
    
    mem = [0] * (T + 2)
    print(memSearch(1))
    
    f = [0] * (T + 3)  # f[i] 表示从第i个店铺开始洗劫能获取的最大现金数
    print(recursFind(T))
 
    print(recursFindPlus(T))

```

注意mian函数内定义的已经是全局变量所以其他函数中可以直接拿来使用

## 三角寻路

> 输入r为行数，然后输入r行，第i行有i个数，构成三角
>
> 问从三角最顶部开始寻路依次往下走，走过的路程的最大长度是多少？（每次只能走左右两边）

#### 注意点

注意f[i] [j]表示以i行j列为终点的路径的最长路径和

注意递推空间的优化

状态转移方程：
$$
f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + tangleList[i - 1][j - 1]
$$
注意f[i] [j]是表示表示以第i行第j列为终点产生的最大的路径和，tangleList[i - 1] [j - 1] 是第i行第j列的值（从第一行开始的）

因为第i行第j列的状态只是由上一个的状态转移过来的，i是有规律一直往下的
则 f_s[j] = max(f_s[j], f_s[j + 1]) + tangleList [i - 1] [j - 1]就表示上一行的第j列的最优与第j+1列的最优的最大值加上当前i行j列的值

同样还是三个函数

#### 代码

```python
# dfs存坐标，控制访问的边界
def dfs(x, y):
    if x > r or y > r:
        return 0
    # 求最优的子问题，
    # 就是看往左dfs(x + 1, y)或者往右dfs(x, y + 1)的最大值，
    # 记得加上当前值tangleList[x][y]（因为算的是和）
    return max(dfs(x + 1, y), dfs(x + 1, y + 1)) + tangleList[x - 1][y - 1]


# 记忆化搜索优化
def dfs_mem(x, y):
    if mem[x][y] != 0:
        return mem[x][y]
    sums = 0
    if x > r or y > r:
        sums = 0
    # 求最优的子问题，
    else:
        sums = max(dfs_mem(x + 1, y), dfs_mem(x + 1, y + 1)) + tangleList[x - 1][y - 1]
    mem[x][y] = sums  # 记录值
    # print(mem)
    return sums


# 递推优化
# 从下往上推，第一个点一定是终点
def dp():
    for i in range(r, 0, -1):
        for j in range(1,i+1):
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + tangleList[i - 1][j - 1]
            # print(" :", f)
    return f[1][1]


# 从上往下推最后一个点不一定，但是起点一定是第一个点1，1
# f[i][j]就表示以第i行第j列为终点产生的最大的路径和，而题目只要求到达底部的最大路径所以说要找底部f[r]中的最大值
def dp_reverse():
    for i in range(1,r+1):
        for j in range(1,i+1):
            f[i][j] = max(f[i - 1][j], f[i - 1][j - 1]) + tangleList[i - 1][j - 1]
            # print(" :", f)
    return max(f[r])

# 递推空间优化
# 因为第i行第j列的状态只是由上一个的状态转移过来的，i是有规律一直往下的
# 则 f_s[j] = max(f_s[j], f_s[j + 1]) + tangleList[i - 1][j - 1]就表示上一行的第j列的最优与第j+1列的最优的最大值加上当前i行j列的值
def dp_space():
    for i in range(r, 0, -1):
        for j in range(1,i+1):
            f_s[j] = max(f_s[j], f_s[j + 1]) + tangleList[i - 1][j - 1]
    return f_s[1]



if __name__ == '__main__':
    r = int(input())
    tangleList = [[0] * r for i in range(r)]

    # 输入三角
    for i in range(r):
        tangleList[i] = list(map(int, input().split())) + [0] * (r - i + 1)
    # print(tangleList)

    mem = [[0] * (i + 2) for i in range(r+2)]
    print(dfs_mem(1, 1))

    # f = [[0] * (r + 2) for i in range(r + 2)]
    # print(dp())

    f = [[0] * (r + 2) for i in range(r + 2)]
    print(dp_reverse())

    f_s = [0] * (r + 2)
    print(dp_space())

    # print(dp_space2())
```


## 补充：日期计算

> 输入两个日期，返回日期之间的分钟数间隔

### *代码*

```python
from datetime import datetime

def calculate_time_difference():
    # 定义时间格式
    time_format = "%Y-%m-%d-%H:%M"
    
    # 提示用户输入两个时间
    time_str1 = input("请输入第一个时间（格式：YYYY-MM-DD-HH:MM）：")
    time_str2 = input("请输入第二个时间（格式：YYYY-MM-DD-HH:MM）：")
    
    try:
        # 将时间字符串转换为datetime对象
        time1 = datetime.strptime(time_str1, time_format)
        time2 = datetime.strptime(time_str2, time_format)
        
        # 计算两个时间之间的差值（timedelta对象）
        time_difference = time2 - time1
        
        # 将时间差转换为分钟数
        minutes_difference = time_difference.total_seconds() / 60
        
        # 输出结果
        print(f"两个时间之间的分钟数间隔为：{minutes_difference}分钟")
    except ValueError as e:
        print("输入的时间格式不正确，请确保格式为YYYY-MM-DD-HH:MM。错误信息：", e)

# 调用函数
calculate_time_difference()
```

### 程序说明：

1. **用户输入**：
   - 使用`input()`函数提示用户输入两个时间字符串。
   - 用户需要按照指定的格式（`YYYY-MM-DD-HH:MM`）输入时间。
2. **异常处理**：
   - 使用`try-except`块来捕获可能的错误，例如输入的时间格式不正确。
   - 如果输入格式错误，程序会提示用户并显示错误信息。
3. **时间计算**：
   - 将输入的时间字符串转换为`datetime`对象。
   - 计算两个时间之间的差值，并将其转换为分钟数。

### 示例运行：

假设用户输入以下时间：

复制

```
请输入第一个时间（格式：YYYY-MM-DD-HH:MM）：2007-06-23-11:59
请输入第二个时间（格式：YYYY-MM-DD-HH:MM）：2007-06-23-12:00
```

程序输出：

```
两个时间之间的分钟数间隔为：1.0分钟
```

如果用户输入的时间格式不正确，例如输入了`2007-06-23-11:5`，程序会提示：

```
输入的时间格式不正确，请确保格式为YYYY-MM-DD-HH:MM。错误信息： time data '2007-06-23-11:5' does not match format '%Y-%m-%d-%H:%M'
```

这个程序可以灵活处理用户输入的时间，并计算出两个时间之间的分钟数间隔。

# Day6 动态规划递推复习

## 最少花费跳楼梯

> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
> 输入n，n为cost列表的长度，自然楼梯是从第0层到第n-1层
>
> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。
>
> 直到你处于第n层的时候，你才真正达到顶端，结束。
>
> 请你计算并返回达到楼梯顶部的最低花费。

### 分析

还是原来昨天那牢三样，递归，记忆化搜索，递推。

核心要点是抓住状态转移方程，多定义列表，如定义了f[i]，那么f[i]代表的含义是什么，他会参与怎样的运算，它与临近的元素之间满足什么关系，**边界在哪**。

### 代码

```python
# 简单暴力
def solve(x):
    # 若超过最大台阶数n-1，即处于第n个或者更大，说明已经到达顶部，则返回0
    if x == 0 or x == 1:
        return 0
    else:  # 考虑最后一步，最后一步是跨2层的能量低一点还是跨1层能量低一点
        return min(solve(x - 1) + cost[x - 1], solve(x - 2) + cost[x - 2])


# 记忆化搜索优化
def solve_mem(x):
    if (mem[x] != 0):
        return mem[x]
    if x == 0 or x == 1:
        sums = 0
    else:
        sums = min(solve(x - 1) + cost[x - 1], solve(x - 2) + cost[x - 2])
    #     利用sums存变量并返回结果
    mem[x] = sums
    return sums


# 递推优化
def cursion_solve(x):
    # 到第n层就结束，f[i]表示的就是从开始到第i层的最小消费
    for i in range(2,x+1):  # 从顶部n开始向下
        # 要包含第2层并且不考虑第0和1层的消费（因为可以直接选从0或者1开始，自然是0）
        # i 从2开始 ，f[2]就表示从开始到第三层的最小消费，自然是min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2])
        f[i] = min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2])
    # print(f)

    # 返回f[n]表示从开始到第n层的最小消费
    return f[n]


if __name__ == '__main__':
    # 总共0到n-1层楼梯
    n = int(input())
    #  cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用
    cost = list(map(int, input().split(' ')))
    # solve(x)表示的是从第x层开始到顶能取得的最大数

    print(solve(n))

    mem = [0] * (n + 1)
    print(solve_mem(n))

    # f[i]表示从第i层开始到达顶部的最小花费
    f = [0] * (n + 1)
    print(cursion_solve(n))

```

## 最长子序列

> 给定数组，寻找数组中最长的递增的子序列的长度

### 代码：

```python
# 递归加记忆化搜索
def L(x):
    if x in memo:
        return memo[x]
    if x == len(num) - 1:
        return 1

    max_len = 1
    for i in range(x + 1, len(num)):
        if num[i] > num[x]:
            # 与以下一个点为起点的最短路径长度进行比较并做更新
            max_len = max(max_len, L(i) + 1)

    memo[x] = max_len
    return max_len


def recursion_search():
    n = len(num)  # 获取数组长度
    f = [1] * n   # 初始化数组，每个位置的最长递增子序列长度至少为1

    for x in range(n):  # 遍历每个位置
        for i in range(x):  # 检查所有小于x的位置
            if num[x] > num[i]:  # 如果当前元素大于之前的某个元素
                f[x] = max(f[x], f[i] + 1)  # 更新以x为结尾的最长递增子序列长度

    return max(f)  # 返回最长递增子序列的最大长度


if __name__ == '__main__':
    n = int(input())
    num = list(map(int, input().split(' ')))

    """定义哈希表存储以x为起点的最大路径长度"""
    memo = {}
    print(L(0))  # 最长递增子序列为1，2，3，4，5长度为5

    f = [0] * (n + 1)  # f[i]表示以num[i]结尾的最长子序列长度
    print(recursion_search())  # 最长递增子序列为1，2，3，4，5长度为5

```



## 方法总结

![image-20250126180646074](C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250126180646074.png)

1. 重述问题：问题要求干什么
2. 找到最后一步
3. 去掉最后一步，问题变成了什么
4. 定义列表，写状态转移方程
