# Day 1 背包问题

## 01背包问题

> 有一个箱子容量为 V*V*，同时有 n*n* 个物品，每个物品有一个体积。
>
> 现在从 n*n* 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

代码：

```python
def knapsack(weights, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)

    for i in range(n):
        for j in range(capacity, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 修正状态转移方程

    return capacity - dp[capacity]  # 返回最小剩余空间


if __name__ == '__main__':
    V = int(input())
    n = int(input())
    vlist = []
    for i in range(n):
        vlist.append(int(input()))
    print(knapsack(vlist, V))

```

双重循环这段代码是解决0-1背包问题的核心部分，它的作用是通过动态规划逐步填充一个一维数组 `dp`，以找到在给定容量下能够装入的最大体积。以下是对这段代码的详细解释：

------

### 代码结构

Python复制

```python
for i in range(n):  # 遍历所有物品
    for j in range(capacity, weights[i] - 1, -1):  # 从大到小遍历背包容量
        dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 状态转移方程
```

------

### 1. **外层循环：遍历物品**

Python复制

```python
for i in range(n):
```

- 这个循环的作用是逐个考虑每一个物品。
- `n` 是物品的总数，`i` 是当前考虑的物品的索引。
- 每次循环处理一个物品，决定是否将其加入背包。

------

### 2. **内层循环：遍历背包容量**

Python复制

```python
for j in range(capacity, weights[i] - 1, -1):
```

- 这个循环的作用是考虑当前物品是否能加入到不同容量的背包中。
- `j` 表示当前背包的容量，从 `capacity`（背包的最大容量）开始，逐步减少到 `weights[i]`。
- **为什么从大到小遍历？**
  - 如果从大到小遍历，每次更新 `dp[j]` 时，`dp[j - weights[i]]` 是基于之前状态的值（即未考虑当前物品 `i` 的状态）。这样可以避免重复使用同一个物品。
  - 如果从小到大遍历，`dp[j - weights[i]]` 可能已经被更新过，这会导致同一个物品被多次使用，从而变成完全背包问题。

------

### 3. **状态转移方程**

Python复制

```python
dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
```

- 这是动态规划的核心部分，用于更新 `dp[j]` 的值。

- `dp[j]` 表示在背包容量为 `j` 的情况下，能够装入的最大体积。

- 状态转移方程的含义是：

  - 如果不选择当前物品 `i`，则背包容量为 `j` 时的最大体积仍然是 `dp[j]`。
  - 如果选择当前物品 `i`，则背包容量为 `j` 时的最大体积是 `dp[j - weights[i]] + weights[i]`，即在容量为 `j - weights[i]` 的情况下加上当前物品的体积。

- 最终，`dp[j]` 的值是两种情况中的最大值：

  Python复制

  ```python
  dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
  ```

------

### 4. **代码的执行过程**

假设背包容量为 `V`，物品体积为 `[w1, w2, ..., wn]`，以下是代码的执行过程：

1. 初始化 `dp` 数组，`dp[0] = 0`（容量为0时，最大体积为0），其余位置初始化为0。
2. 遍历每个物品 `i`：
   - 对于每个物品，从大到小遍历背包容量 `j`。
   - 对于每个容量 `j`，如果当前物品 `i` 的体积 `weights[i]` 小于等于 `j`，则考虑是否将物品 `i` 放入背包。
   - 更新 `dp[j]` 为两种情况的最大值：
     - 不放入物品 `i`：`dp[j]` 保持不变。
     - 放入物品 `i`：`dp[j] = dp[j - weights[i]] + weights[i]`。
3. 最终，`dp[capacity]` 表示在背包容量为 `capacity` 的情况下，能够装入的最大体积。

------

### 5. **输出结果**

最终结果是 `capacity - dp[capacity]`，表示背包的最小剩余空间。

------

### 示例

假设背包容量为 `V = 10`，物品体积为 `[3, 4, 5]`，以下是代码的执行过程：

1. 初始化 `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`。
2. 遍历第一个物品（体积为3）：
   - 更新 `dp[3]` 到 `dp[10]`：
     - `dp[3] = max(dp[3], dp[0] + 3) = 3`
     - `dp[4] = max(dp[4], dp[1] + 3) = 3`
     - ...
     - `dp[10] = max(dp[10], dp[7] + 3) = 3`
3. 遍历第二个物品（体积为4）：
   - 更新 `dp[4]` 到 `dp[10]`：
     - `dp[4] = max(dp[4], dp[0] + 4) = 4`
     - `dp[7] = max(dp[7], dp[3] + 4) = 7`
     - ...
4. 遍历第三个物品（体积为5）：
   - 更新 `dp[5]` 到 `dp[10]`：
     - `dp[5] = max(dp[5], dp[0] + 5) = 5`
     - `dp[10] = max(dp[10], dp[5] + 5) = 10`
5. 最终，`dp = [0, 0, 0, 3, 4, 5, 3, 7, 5, 8, 10]`。
6. 输出结果：`10 - dp[10] = 0`。

------

通过这段代码，我们能够动态地计算出在给定容量下能够装入的最大体积，从而求出最小剩余空间。

## 01背包问题（加上价值权重）

> ```
> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
> 如果你是辰辰，你能完成这个任务吗？
> ```

具体看代码注释：

```python
def knapsack(value, weight, capacity):
    n = len(value)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]  # 实际长度为容量加1（要考量容量为0的情况）
    # 0行和0列一定为0
    for i in range(1, n + 1):  # 要添加的物品价值为i时(按行遍历)
        for j in range(1, capacity + 1):  # 遍历每一种容量的背包 j为容量
            if weight[i - 1] <= j:
                # 当容量足够加入该物品时,进行对比
                """如果没有这个物品介入时,同为j容量的背包能装得的物品最大价值dp[i - 1][j]
                以及如果选择装入这个物品(value[i - 1])与剩下容量能装入的最大价值dp[i - 1][j - weight[i - 1]]的和
                在两者之间比较最大值取就行
                """
                dp[i][j] = max(value[i - 1] + dp[i - 1][j - weight[i - 1]], dp[i - 1][j])
            else:  # 当要添加的物品加不进背包时候,最优解就是同容量背包不加这个物品的时候的最优解
                dp[i][j] = dp[i - 1][j]

    # 最后一行的capacity列的值就是所求的最优解, 即容量为capacity的背包能装入的物品最大价值
    return dp[n][capacity]


if __name__ == '__main__':
    T, M = map(int, input().split(' '))
    # T就是背包容量
    tlist = []  # 存每个物品的耗时(即物品需要的背包容量)
    mlist = []  # 存每个物品价值
    for i in range(M):
        t, m = map(int, input().split(' '))
        tlist.append(t)
        mlist.append(m)

    print(knapsack(mlist, tlist, T))
```

# Day2 快速幂算法

> 快速幂算法（也称为“快速指数运算”或“快速幂取模”）是一种高效的算法，用于计算 *a**b*mod*m*，即计算 *a* 的 *b* 次幂对 *m* 取模的结果。该算法的核心思想是通过将指数 *b* 分解为二进制形式，从而将问题分解为若干个较小的幂次运算，大大减少了计算量。快速幂算法的核心是每个数的n次方，则分解为数的形式，如2的7次方可以分解为2的1次方乘以2的2次方乘以2的四次方.而对应的二进制中为1位是有规律的。

### 1. **快速幂算法的基本原理**

快速幂算法利用了指数的二进制表示和幂的性质。具体来说，任何整数 *b* 都可以表示为二进制形式，例如：

*b*=*b**k*⋅2*k*+*b**k*−1⋅2*k*−1+⋯+*b*1⋅21+*b*0⋅20

其中 *b**i* 是二进制位（0 或 1）。因此：

*a**b*=*a**b**k*⋅2*k*+*b**k*−1⋅2*k*−1+⋯+*b*1⋅21+*b*0⋅20

根据幂的性质，可以进一步分解为：

*a**b*=(*a*2*k*)*b**k*⋅(*a*2*k*−1)*b**k*−1⋅⋯⋅(*a*21)*b*1⋅(*a*20)*b*0

由于 *b**i* 只能是 0 或 1，因此 *a*2*i* 只有在 *b**i*=1 时才会被乘入最终结果。

### 2. **快速幂算法的实现步骤**

快速幂算法的核心是通过循环逐步计算 *a*2*i*，并根据 *b**i* 的值决定是否将其乘入最终结果。具体步骤如下：

#### 输入：

- *a*：基数
- *b*：指数
- *m*：模数

#### 输出：

- *a**b*mod*m*

#### 算法步骤：

1. 初始化结果为 1，即 result=1。
2. 将基数 *a* 对模数 *m* 取模，即 *a*=*a*mod*m*。
3. 遍历指数 *b* 的每一位（从最低位到最高位）：
   - 如果当前位为 1（即 *b**i*=1），则将当前的 *a*2*i* 乘入结果，并对 *m* 取模。
   - 将基数 *a* 平方，并对 *m* 取模，即 *a*=(*a*×*a*)mod*m*。
   - 将指数 *b* 右移一位（相当于除以 2）。
4. 当指数 *b* 为 0 时，循环结束，返回结果。

### 3. **Python 实现**

以下是快速幂算法的 Python 实现：

```python
def Binexp(a,n):
    r = 1
    while n > 0:
        if n % 2 == 1:  #如果n的二进制最后一位是1，则乘入r
            r *= a
        a *= a  #a更新到下一个为偶次方的值上
        n //= 2  #n //= 2的含义就是将n的二进制的最后一位消灭掉
    return r
```

当然，可以将其中的一些运算换成位运算，与运算

```python
def Binexp(a, n):
    r = 1
    while n > 0:
        if n & 1:  #n & 1表示n与1的二进制做位运算，只看最后一位是否相等，相等说明n的二进制最后一位是1
            r *= a
        a *= a
        n >>= 1  # n 对2整除并向下取整等效于将n的二进制右移一位
    return r
```



### 4. **快速幂算法的优势**

- **时间复杂度**：快速幂算法的时间复杂度为 *O*(log*b*)，因为每次循环都将指数 *b* 减半。
- **空间复杂度**：快速幂算法的空间复杂度为 *O*(1)，因为它只需要常数级的额外空间。
- **适用场景**：特别适用于大整数的幂运算和模运算，例如在密码学和数论问题中。

### 5. 取模

> 小蓝想要构造出一个长度为10000 的数字字符串，有以下要求：
>
> 1) 小蓝不喜欢数字 0 ，所以数字字符串中不可以出现 0 ；
> 2) 小蓝喜欢数字 3 和 7 ，所以数字字符串中必须要有 3 和 7 这两个数字。
>
> 请问满足题意的数字字符串有多少个？这个数字会很大，你只需要输出其对 109 + 7 取余后的结果。

### 原理：<img src="C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250121125032521.png" alt="image-20250121125032521" style="zoom:50%;" />

在适当位置加入取模运算即可

a的n次方对m取模

代码：

```python
def qumo(a, n, m):
    a = a % m  # 将基数 a 对模数 m 取模，减少后续计算中的数值大小
    r = 1      # 初始化结果 r 为 1（因为任何数的 0 次幂都是 1）
    while n > 0:  # 当指数 n 大于 0 时继续循环
        if n & 1 == 1:  # 如果 n 的二进制最低位是 1
            r = (r * a) % m  # 将当前的 a 乘入结果 r，并对 m 取模
        a = (a * a) % m  # 将 a 平方，并对 m 取模
        n >>= 1  # 将 n 右移一位（相当于 n = n // 2）
    return r  # 返回最终结果
```

按为了求解这个问题，我们需要计算满足以下条件的长度为10000的数字字符串的数量：

1. 字符串中不能包含数字0。
2. 字符串中必须包含数字3和7。

首先，我们计算不包含数字0的长度为10000的数字字符串的总数。由于每个位置可以是1到9中的任意一个数字，所以总共有 910000 个这样的字符串。

接下来，我们需要减去不包含数字3或不包含数字7的字符串数量。不包含数字3的字符串中，每个位置可以是1到9中除了3以外的8个数字，所以总共有 810000 个这样的字符串。同样，不包含数字7的字符串也有 810000 个。

但是，我们减去的太多了，因为那些既不包含数字3也不包含数字7的字符串被减去了两次。所以，我们需要加上既不包含数字3也不包含数字7的字符串数量。这样的字符串中，每个位置可以是1到9中除了3和7以外的7个数字，所以总共有 710000 个这样的字符串。

因此，满足条件的字符串数量为： 910000−2⋅810000+710000

由于这个数字非常大，我们需要对 109+7 取余。我们可以使用快速幂算法来计算 910000mod(109+7)，810000mod(109+7)，和 710000mod(109+7)

```python
print((qumo(9, 10000,10**9+7)-2*qumo(8,10000,10**9+7)+qumo(7,10000,10**9+7))%(10**9+7))
```



## 6. 斐波那契的第i项

原理：

<img src="C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20250121130923474.png" alt="image-20250121130923474" style="zoom:50%;" />

所以，只需要计算出矩阵的n次方就可以得到第n项的值

最重要的就是计算矩阵的n次方

```python
import numpy as np
def fibonacci3(n):
    A = np.array([[0, 1], [1, 1]], dtype=np.object_)
    R = np.eye(A.shape[0], dtype=np.object_)
    while n > 0:
        if n & 1:
            R = np.dot(R, A)
        A = np.dot(A, A)
        n >>= 1
    return R[1,0]

```

 A = np.array([[0, 1], [1, 1]], dtype=np.object_)创建一个矩阵A

R是初始化一个基于A的形状的0矩阵

返回的R[1,0]就是我们需要的值

### 6. **总结**

快速幂算法是一种高效且实用的算法，通过将指数分解为二进制形式，利用幂的性质和模运算的性质，大大减少了计算量。它不仅适用于大整数的幂运算，还可以在模运算中高效地计算结果，是解决相关问题的重要工具。

## 补充：对于py中的`np.dot` 

`np.dot` 是 NumPy 库中的一个函数，用于计算两个数组的点积（dot product）。它是一个非常强大的函数，可以处理向量、矩阵以及更高维度数组的乘法运算。以下是对 `np.dot` 的详细解释和一些常见用法。

------

### 1. **点积的基本概念**

点积（dot product）是线性代数中的一个基本运算，用于计算两个向量的乘积。对于两个向量 a 和 b，它们的点积定义为：

a⋅b=i=1∑naibi

其中 ai 和 bi 是向量的对应元素。

对于矩阵，点积通常表示为矩阵乘法。如果 A 是一个 m×n 矩阵，B 是一个 n×p 矩阵，那么它们的点积 C=A⋅B 是一个 m×p 矩阵，其中每个元素 Cij 由以下公式计算：

Cij=k=1∑nAikBkj

------

### 2. **`np.dot` 的用法**

`np.dot` 可以处理多种类型的数组，包括一维数组（向量）、二维数组（矩阵）以及更高维度的数组。它的行为会根据输入数组的维度而有所不同。

#### 2.1 **向量点积**

如果输入是两个一维数组，`np.dot` 计算它们的点积。

Python复制

```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = np.dot(a, b)
print(result)  # 输出：32 (1*4 + 2*5 + 3*6)
```

#### 2.2 **矩阵乘法**

如果输入是两个二维数组，`np.dot` 计算它们的矩阵乘积。

Python复制

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

result = np.dot(A, B)
print(result)
# 输出：
# [[19 22]
#  [43 50]]
```

#### 2.3 **多维数组**

对于更高维度的数组，`np.dot` 的行为会更复杂。它会沿着最后一个轴进行点积运算。

Python复制

```python
A = np.random.rand(2, 3, 4)
B = np.random.rand(2, 4, 5)

result = np.dot(A, B)
print(result.shape)  # 输出：(2, 3, 5)
```

------

### 3. **`np.dot` 与 `@` 运算符**

从 Python 3.5 开始，`@` 运算符被引入，用于表示矩阵乘法。在 NumPy 中，`@` 运算符与 `np.dot` 的行为相同。

Python复制

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

result = A @ B  # 等价于 np.dot(A, B)
print(result)
# 输出：
# [[19 22]
#  [43 50]]
```

------

### 4. **注意事项**

1. **维度匹配**：
   - 对于向量点积，两个数组的长度必须相同。
   - 对于矩阵乘法，第一个矩阵的列数必须等于第二个矩阵的行数。
   - 对于更高维度的数组，最后一个轴的维度必须匹配。
2. **性能优化**：
   - NumPy 的 `np.dot` 是高度优化的，底层使用了 BLAS（Basic Linear Algebra Subprograms）库，因此在处理大规模数据时非常高效。
3. **与 `np.matmul` 的区别**：
   - `np.dot` 和 `np.matmul` 在处理二维数组时行为相同，但在处理一维数组时有所不同。`np.matmul` 会将一维数组视为二维数组（列向量或行向量），而 `np.dot` 则直接计算点积。

------

### 5. **总结**

`np.dot` 是 NumPy 中用于计算点积和矩阵乘法的核心函数。它支持多种输入维度，并且在性能上经过高度优化。如果你需要进行线性代数运算，`np.dot` 是一个非常强大的工具。
