# Day 1 背包问题

## 01背包问题

> 有一个箱子容量为 V*V*，同时有 n*n* 个物品，每个物品有一个体积。
>
> 现在从 n*n* 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

代码：

```python
def knapsack(weights, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)

    for i in range(n):
        for j in range(capacity, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 修正状态转移方程

    return capacity - dp[capacity]  # 返回最小剩余空间


if __name__ == '__main__':
    V = int(input())
    n = int(input())
    vlist = []
    for i in range(n):
        vlist.append(int(input()))
    print(knapsack(vlist, V))

```

双重循环这段代码是解决0-1背包问题的核心部分，它的作用是通过动态规划逐步填充一个一维数组 `dp`，以找到在给定容量下能够装入的最大体积。以下是对这段代码的详细解释：

------

### 代码结构

Python复制

```python
for i in range(n):  # 遍历所有物品
    for j in range(capacity, weights[i] - 1, -1):  # 从大到小遍历背包容量
        dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])  # 状态转移方程
```

------

### 1. **外层循环：遍历物品**

Python复制

```python
for i in range(n):
```

- 这个循环的作用是逐个考虑每一个物品。
- `n` 是物品的总数，`i` 是当前考虑的物品的索引。
- 每次循环处理一个物品，决定是否将其加入背包。

------

### 2. **内层循环：遍历背包容量**

Python复制

```python
for j in range(capacity, weights[i] - 1, -1):
```

- 这个循环的作用是考虑当前物品是否能加入到不同容量的背包中。
- `j` 表示当前背包的容量，从 `capacity`（背包的最大容量）开始，逐步减少到 `weights[i]`。
- **为什么从大到小遍历？**
  - 如果从大到小遍历，每次更新 `dp[j]` 时，`dp[j - weights[i]]` 是基于之前状态的值（即未考虑当前物品 `i` 的状态）。这样可以避免重复使用同一个物品。
  - 如果从小到大遍历，`dp[j - weights[i]]` 可能已经被更新过，这会导致同一个物品被多次使用，从而变成完全背包问题。

------

### 3. **状态转移方程**

Python复制

```python
dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
```

- 这是动态规划的核心部分，用于更新 `dp[j]` 的值。

- `dp[j]` 表示在背包容量为 `j` 的情况下，能够装入的最大体积。

- 状态转移方程的含义是：

  - 如果不选择当前物品 `i`，则背包容量为 `j` 时的最大体积仍然是 `dp[j]`。
  - 如果选择当前物品 `i`，则背包容量为 `j` 时的最大体积是 `dp[j - weights[i]] + weights[i]`，即在容量为 `j - weights[i]` 的情况下加上当前物品的体积。

- 最终，`dp[j]` 的值是两种情况中的最大值：

  Python复制

  ```python
  dp[j] = max(dp[j], dp[j - weights[i]] + weights[i])
  ```

------

### 4. **代码的执行过程**

假设背包容量为 `V`，物品体积为 `[w1, w2, ..., wn]`，以下是代码的执行过程：

1. 初始化 `dp` 数组，`dp[0] = 0`（容量为0时，最大体积为0），其余位置初始化为0。
2. 遍历每个物品 `i`：
   - 对于每个物品，从大到小遍历背包容量 `j`。
   - 对于每个容量 `j`，如果当前物品 `i` 的体积 `weights[i]` 小于等于 `j`，则考虑是否将物品 `i` 放入背包。
   - 更新 `dp[j]` 为两种情况的最大值：
     - 不放入物品 `i`：`dp[j]` 保持不变。
     - 放入物品 `i`：`dp[j] = dp[j - weights[i]] + weights[i]`。
3. 最终，`dp[capacity]` 表示在背包容量为 `capacity` 的情况下，能够装入的最大体积。

------

### 5. **输出结果**

最终结果是 `capacity - dp[capacity]`，表示背包的最小剩余空间。

------

### 示例

假设背包容量为 `V = 10`，物品体积为 `[3, 4, 5]`，以下是代码的执行过程：

1. 初始化 `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`。
2. 遍历第一个物品（体积为3）：
   - 更新 `dp[3]` 到 `dp[10]`：
     - `dp[3] = max(dp[3], dp[0] + 3) = 3`
     - `dp[4] = max(dp[4], dp[1] + 3) = 3`
     - ...
     - `dp[10] = max(dp[10], dp[7] + 3) = 3`
3. 遍历第二个物品（体积为4）：
   - 更新 `dp[4]` 到 `dp[10]`：
     - `dp[4] = max(dp[4], dp[0] + 4) = 4`
     - `dp[7] = max(dp[7], dp[3] + 4) = 7`
     - ...
4. 遍历第三个物品（体积为5）：
   - 更新 `dp[5]` 到 `dp[10]`：
     - `dp[5] = max(dp[5], dp[0] + 5) = 5`
     - `dp[10] = max(dp[10], dp[5] + 5) = 10`
5. 最终，`dp = [0, 0, 0, 3, 4, 5, 3, 7, 5, 8, 10]`。
6. 输出结果：`10 - dp[10] = 0`。

------

通过这段代码，我们能够动态地计算出在给定容量下能够装入的最大体积，从而求出最小剩余空间。

## 01背包问题（加上价值权重）

> ```
> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
> 如果你是辰辰，你能完成这个任务吗？
> ```

具体看代码注释：

```python
def knapsack(value, weight, capacity):
    n = len(value)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]  # 实际长度为容量加1（要考量容量为0的情况）
    # 0行和0列一定为0
    for i in range(1, n + 1):  # 要添加的物品价值为i时(按行遍历)
        for j in range(1, capacity + 1):  # 遍历每一种容量的背包 j为容量
            if weight[i - 1] <= j:
                # 当容量足够加入该物品时,进行对比
                """如果没有这个物品介入时,同为j容量的背包能装得的物品最大价值dp[i - 1][j]
                以及如果选择装入这个物品(value[i - 1])与剩下容量能装入的最大价值dp[i - 1][j - weight[i - 1]]的和
                在两者之间比较最大值取就行
                """
                dp[i][j] = max(value[i - 1] + dp[i - 1][j - weight[i - 1]], dp[i - 1][j])
            else:  # 当要添加的物品加不进背包时候,最优解就是同容量背包不加这个物品的时候的最优解
                dp[i][j] = dp[i - 1][j]

    # 最后一行的capacity列的值就是所求的最优解, 即容量为capacity的背包能装入的物品最大价值
    return dp[n][capacity]


if __name__ == '__main__':
    T, M = map(int, input().split(' '))
    # T就是背包容量
    tlist = []  # 存每个物品的耗时(即物品需要的背包容量)
    mlist = []  # 存每个物品价值
    for i in range(M):
        t, m = map(int, input().split(' '))
        tlist.append(t)
        mlist.append(m)

    print(knapsack(mlist, tlist, T))
```



